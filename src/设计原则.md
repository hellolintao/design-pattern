# 单一职责原则SRP

- 就一个类而言，应该仅有一个引起它变化的原因ASD
- 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱
- 或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时
- 设计会遭受到意想不到的破坏ASD
- 如果您呢个够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责

# 开放，封闭原则

**不能修改，但是可以扩展的一种设计思想**

**开放-封闭原则，是说软件实体（类，模块，函数等等）应该可以扩展，但是不可修改**

*对于扩展是开放的，对于修改是封闭的*
*Open for extension, Closed for modification*

## 提出关键问题

> 怎样的设计才能面对需求的改变却可以保持相对稳定，从而使系统可以在第一个版本以后不断推出新的版本呢？

> 无论模块多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。**他必须先猜测出最有可能发生的变化的种类**，然后构造抽象来隔离那些变化。

> 在我们最初编写代码时，假设变化不会发生，当变化发生时，我们就创建抽象来隔离以后发生的同类变化。

**面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码**

_比如之前的计算类，就是抽象出来了Operation类，这个抽象类，无论拓展什么计算，只要是两个数之间的，都不用去修改这个抽象类_

开放封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可拓展、可复用、灵活性好。

开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序的每个部分都进行刻意抽象同样不是一个好主意。

拒绝不成熟的抽象和抽象本身一样重要。


# 依赖倒转原则

>抽象不应该依赖细节，细节应该依赖于抽象（针对接口编程，不要对实现编程）

- 高层模块不应该依赖低层模块，两个都应该依赖抽象
- 抽象不应该依赖细节，细节应该依赖抽象

（比如我写了一套程序，可以兼容很多数据库，我有一套数据库，很多技术都可以去使用它，这就是依赖倒转原则）

# 里氏代换原则: 子类型必须能够替换掉它们的父类型。

一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别，也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。

程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象设计！


# 迪米特法则

类之间要松耦合，复用率才高。
一个类要包装包自己的private字段，不需要让别的类知道的就不要公开。
**每一个类都尽量降低成员的访问权限**






